
#%%
import IPython.display as ipyd


#%%
from IPython.display import Markdown

ideas = open('./design/ideas.md')
output = ideas.read()

Markdown(output)

#%% [markdown]
# ### Problem type description template
#%% [markdown]
# ### Problem type title
# 
# Description
# 
# #### Problem generation
# 
# Outline of algorithm for generating problem
# 
# #### Problem template
# 
# Form the problem takes
# 
# #### Solution generation
# 
# Outline of algorithm for generating solution
# 
# #### Solution template
# 
# Form the solution takes
#%% [markdown]
# ### Given $f(x)$, find $f(-x)$

#%%
from sympy import symbols, Poly, Rational, latex
from numpy import random, around, arange
from numpy.random import randint, rand
from problem import create_full_text_problem
from testbed_utils import render_debug_problem
from util import fmath

def polynomial_function_find_negative():

    max_coeff_abs = 144
    min_degree = 2
    max_degree = 5

    degree = randint(min_degree, max_degree)

    coeffs = around(random.rand(6)*(max_coeff_abs*2))-max_coeff_abs

    x = symbols('x')

    # f(x)
    expr = 0
    # f(-x)
    neg_expr = 0

    # arange is half open; it doesn't include the top value, so we add 1
    for i in arange(degree-1)+1:
        coeff = Rational(coeffs[int(i)])
        power = Rational(degree-i)
        
        expr += coeff*(x)**power
        neg_expr += coeff*(-x)**power

    question = fmath("f(x) = "+latex(expr))

    answer = fmath("f(-x) = "+latex(neg_expr))

    return create_full_text_problem([question], [answer])

render_debug_problem(polynomial_function_find_negative())

#%% [markdown]
# ### Complete the square
# 
# Generate an equation from a perfect square, then remove the term with the lowest degree and add some other number. Not sure what rule should be used when generating this other number.
# 
# #### Problem generation
# 
# 1. Generate $c$ for $(x + c)$ within some predetermined bounds. $c$ can be negative.
# 2. Evaluate $(x + c)^2$ for an output of $x^2+xc+c^2$.
# 3. Optionally multiply this by an integer within some bounds, so an extra step has to be taken to factor when solving, for an output of $ax^2+axc+ac^2$
# 4. Remove $ac^2$ for an output of $ax^2+axc)$.
# 5. Add another number $n$ and make it equal zero for $ax^2+axc+n=0$
# 
# $ax^2+axc+n=0$
# 
# #### Problem template
# 
# $ax^2+axc+n=0$
# 
# Factor by completing the square.
# 
# #### Solution generation
# 
# $a(x+c)+n-ac^2=0$
# 
# Solution should be in vertex form ($h$ and $k$ are only used because they haven't been defined in the algorithm. They serve only to show the shape of the expression):
# 
# $a(x-h)^2+k=0$
# 
# #### Solution template
# 
# $a(x-h)^2+k=0$

#%%
from sympy import Poly, Rational, expand, simplify, latex, symbols
from numpy import random, around, arange
from numpy.random import rand

def quadratic_function_find_vertex_intercept_form():
    
    # We may want to include fractions for more difficult problems in the future
    min_c = 1
    max_c = 6

    min_n = 1
    max_n = 30

    min_a = 1
    max_a = 5

    c = randint(min_c, max_c)
    n = randint(min_n, max_n)
    a = randint(min_a, max_a)

    c = -c if rand() < 0.5 else c

    x = symbols('x')

    expr = a*(x+c)**2

    # Expand into standard form

    expr = expand(expr)

    # Remove c^2

    expr = expr-a*c**2

    # Add n

    expr = expr+n

    eval_expr = a*(x+c)**2+n-(a*(c**2))

    problem_content = fmath(latex(expr)+' = 0')

    problem_solution = fmath(latex(eval_expr)+' = 0')

    return create_full_text_problem([problem_content], [problem_solution])

render_debug_problem(quadratic_function_find_vertex_intercept_form())

#%% [markdown]
# ### Finding vertex given quadratic
# 
# $-\frac{b}{2a}$
# 
# Quadratics generated by or provided to this type don't need to be neatly factored or have real x-intercepts.

#%%
from sympy import symbols, Rational, UnevaluatedExpr, Array
import numpy as np
from numpy import random
from math import gcd
from functools import reduce

coeff_bounds = (1, 10)

def gen_coeff():
    coeff_abs = random.randint(coeff_bounds[0], coeff_bounds[1])
    coeff = -coeff_abs if random.rand() < 0.5 else coeff_abs
    
    return coeff
    
a, b, c = (gen_coeff(), gen_coeff(), gen_coeff())

x = symbols('x')

gcd = reduce(gcd, (a, b, c))

# Divide coefficients by gcd

a, b, c = Array(np.array([a, b, c])/gcd).applyfunc(lambda coeff: Rational(coeff))

factored_f = a*x**2+b*x+c

latex_expr = latex(factored_f)

f = factored_f*gcd

problem_content = f'{gcd}({latex_expr})' if gcd != 1 else latex_expr

vertex_x = Rational(-b, 2*a)
vertex_y = f.subs(x, vertex_x)

ipyd.Latex(f'problem: ${problem_content}$ solution: ${(vertex_x, vertex_y)}$, gcd:${gcd}$ {(a, b, c)}')

#%% [markdown]
# ### Determining possible number of real roots of quadratic function
# 
# By analyzing discriminant
# 
# 2, 1 (repeated), or 0
# 
# **We need a method to generate a quadratic function that has an equal likelihood of having 0, 1, or 2 roots**

#%%
# 

#%% [markdown]
# ### List transformations
# 
# We're just doing this with $x^2$ right now, but there's not reason we couldn't do it with something else.
# 
# #### Examples
# 
# $x^2+1$: Up by 1
# 
# $x^2-2$: Down by 2
# 
# $(x+5)^2+1/2$: Left by 5, up by 1/2
# 
# $5(x+2)^2+2$: Left by 2, stretch vertically by 5 (compress horizontally by 1/5), up by 2

#%%
# STUB: Do later


